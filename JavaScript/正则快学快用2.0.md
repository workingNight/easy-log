## 正则快学快用

正则在一些文本处理、校验、爬虫的场景下非常有用，不用的情况下也经常会忘记





## 文章摘选

元字符： \n \r  **\s**(匹配空白字符,包括空格、制表符、换页符和换行符)  \d  \w  

数量限定    ？ *  + {n,m}

边界：   单词边界 \b    ^ $开头结尾      img忽略大小写，多行模式，全局模式

**子表达式，分组**

回溯引用 模式的后面部分引用前面已经匹配到的子字符串

\b(\w+)\s\1   这个\1就是引用前面匹配到的

本身不被消费(?)

非捕获：    (?:regex)   

指定后缀  （？=regx)   用来限制后缀， 也就是查找后缀为这个的，相反的（？！regx)查找后缀不为这个的

指定前缀   （？<=regx)用来限制前缀， 相反的（？<!regx)用来查找前缀不为这个的

一些相关函数 match，如果正则带g和正则不带g,带g全部结果，不带g一个对象

```
从一道题里面深入理解
let  d = '12345679'
let b = d.replace(/(\d)(?=(\d{3})+$)/, "$1,") 
(?=(\d{3})+$)就是限定后面的得是成3成3的数字串
(\d)就是捕获到的成3数字串前面的第一个数字，然后这个时候我们在后面进行引用$1然后就替换$1,就行了

$1在replace中常用，  \1在查找重复中常用
```

贪婪与非贪婪

通常的匹配量词都是尽可能的匹配多，如有有多个贪婪，从左到右的每个贪婪，优先最大数量的满足

懒惰，通常在量词限定后面加一个？   *？   +？  ？？ {n,m}？

反义  \W等大写表示非对应

## 总结



